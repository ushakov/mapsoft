В этой директории находятся разные небольшие библиотеки 
нижнего уровня: работа с точками, с цветом, с картинками, с геоданными и т.п.

==================================================================
Разные полезные мелкие объекты.
==================================================================
#include "cache.h"

    class Cache<K,V>

Кэш объектов типа V, упорядоченных по ключу типа K

    Cache (int capacity);
    Cache (Cache const & other);
    void swap (Cache<K,V> & other);
    Cache<K,V> & operator= (Cache<K,V> const& other);

    int add (K const & key, V const & value);
    V & get (K const & key);

    bool contains (K const & key);
    int space_remains();
    void clear();

==================================================================
#include "color.h"

    struct RGB
    struct RGBA

3- и 4-байтовый цвет. Преобразования друг в друга и в int.

    unsigned char r,g,b
    RGB();
    RGB(unsigned char r, unsigned char g, unsigned char b);
    RGB(int c);    
    operator int () const;
    operator RGBA () const;

И для RGBA - аналогично

Не слишком очевидно, надо ли часто использовать эти классы. 
Например, работать с Image<RGB> существенно медленнее, чем
с Image<int>.

С другой стороны, может быть приятно использовать для 
разный преобразований:
Image<int> image(100,100,RGB(r,g,b));
int c = RGB(b[3*i], b[3*i+1], b[3*i+2]);
и т.п.

TODO 
    * сложение и умножение на число??

==================================================================
#include "rainbow.h"

Радуга и пр. цветовые градиенты (из srtm02/color.h)


    RGB rainbow(int n, unsigned short mingrade);

mingrade - чему соответствует n=0:
0 - blue, 1 - сyan, 2 - green etc.
...

    RGB rainbow(int n, int min, int max, int grades, int mingrade);

...

==================================================================
#include "point.h"

    struct Point<T>

Точка на двумерной плоскости. Координаты типа T. Определено
сложение/вычитание, умножение/деление на число, сравнение...

То, что раньше находилось в трех местах:
viewer/pointrect.h
srtm02/point.h
io_new/geo_m.h  g_point
viewer/comparable_pair.h

==================================================================
#include "rect.h"

class Rect<T>

прямоугольник на двумерной плоскости. Координаты типа T.

пришло из viewer/pointrect.h

    T x,y,w,h;
    bool empty() const
    T width() const;
    T height() const;


    Rect<T> intersect (Rect<T> const & R1, Rect<T> const & R2);
    Rect<T> bounding_box (Rect<T> const & R1, Rect<T> const & R2);
    void clip_point_to_rect (Point<T> & p, const Rect<T> & r);
    bool point_in_rect (Point<T> & p, const Rect<T> & r);


==================================================================
#include "pointset.h" -- работа с множествами точек, с границами
    пришло из srtm02/point.h
пока не готово!!!

==================================================================

#include "image.h"

    struct Image<T>

Картинка с окном -- двумерный массив элементов произвольного типа с
настоящим memory management'ом!.

При присвоении и инициализации из другой картинки массив данных не копируется!
(устроен счетчик ссылок на массив, когда ссылок не остается - массив удаляется)

Копирование картинки и данных: image1 = image.copy()

Доступ к точкам картинки: image.get(x,y),  image.set(x,y,c)
Доступ к точкам окна:     image.wget(x,y), image.wset(x,y,c)
В функциях доступа не проверяется выход за границы картинки!
Компилить с ключом -O1 (скорость возрастет раза в три)

Размер картинки: image.w0, image.h0
Размер окна:     image.w,  image.h

Получить размеры окна:
    Rect<int> r = image.window_get();
Установить размеры окна
(если прямоугольник вылезает за картинку - он правильно обрезается):
    image.window_set(r);  
Установить окно во всю картинку:
    image.window_expand();

    bool empty() const;

Вообще, кажется, что окно будет не нужно, когда мы научимся грузить часть картинки.
Пока пусть будет для проверки...
    
Красивая идея делать Image<RGB> не слишком хороша из-за скорости --
работа с Image<int> вдвое быстрее...

TODO
    * может быть, убрать окно...
    * для тестовых целей сделать версии get и set с проверкой диапазона.

==================================================================
    Работа с картинками
==================================================================
#include "image_tiff.h"

Чтение и запись TIFF-файлов, с помощью библиотеки libtiff

    Point<int> tiff_image::size(const char *file);

Определить размер файла. Если файл не TIFF - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалась возвращалось Point<int>(0,0)).

    int tiff_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Никакой интерполяции по этой причине нет.

Используется возможность произвольного доступа к строкам в файлах без
паковки (TIFFTAG_COMPRESSION==COMPRESSION_NONE) или с отдельной
паковкой каждой строчки (TIFFTAG_ROWSPERSTRIP==1). Работа с такими
файлами (вырезание куска, сильное уменьшение) должна быть более
быстрой.

Данные (цветные и ч/б, с прозрачностью и без) читаются в Image<int> в
формате RRGGBBAA.

    Image<int> tiff_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int tiff_image::wsave(
	const char *file, 
	const Image<int> & im, 
	bool usealpha = false
    );
    int tiff_image::save(
	const char * file, 
	const Image<int> & im, 
	bool usealpha = false
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB, в зависимости от параметра usealpha - с
прозрачностью или без. TIFFTAG_COMPRESSION всегда COMPRESSION_LZW,
паковка строчек - отдельная (что убыстряет чтение таких файлов
см.выше).

TODO
    - обработка ошибок

==================================================================
#include <image_jpeg.h>

Чтение и запись JPEG-файлов, с помощью библиотеки libjpeg

    Point<int> jpeg_image::size(const char *file);

Определить размер файла. Если файл не JPEG - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалось Point<int>(0,0)).


    int jpeg_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Используется возможность библиотеки libjpeg
быстро читать файлы, уменьшенные в 2,4,8 раз.  Никакой интерполяции
нет.

Данные (цветные и ч/б) читаются в Image<int> в формате RRGGBB00.

    Image<int> jpeg_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int jpeg_image::wsave(
	const char *file, 
	const Image<int> & im, 
	int quality=75
    );
    int jpeg_image::save(
	const char * file, 
	const Image<int> & im, 
	int quality=75
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB с качеством quality (0..100)

TODO
    - обработка ошибок

==================================================================
#include "image_google.h"

Работа с космоснимками, скачанными с maps.google.com.

Такие картинки имеют равноугольмую продольно-цилиндрическую проекцию
(mercator), и существуют в разных масштабах (1..18). В масштабе 1 весь
Земной шар изображается на одной плитке 256х256 точек. В масштабе
N вся картинка состоит из 2**(N-1)x2**(N-1) плиток 256х256.

Таким образом, при переходе к более крупному масштабу, каждая плитка
делится на 4 части. Части обозначаются буквами q, r, t, s. Исходная
плитка обозначается буквой t.  Адрес некоторой плитки записывается
строчкой из букв, например "tqqrtrssr".

    std::string google::tile2addr(int google_scale, int xt, int yt);

Определить адрес плитки по ее координатам.
Координаты считаются от левого-нижнего угла картинки и должны быть 
в диапазоне 0..2**(google_scale-1)-1.

Скачать такой кусочек можно командой:
wget http://kh<случайное число 0..2>.google.com/kh?n=404&v=9&t=<адрес плитки>

Считается, что локально такие файлы разложены по масштабам в
разные директории:
01/t.jpg
02/tq.jpg
02/tr.jpg
02/ts.jpg
02/tt.jpg
и т.д.

std::string google::tile2file(int google_scale, int xt, int yt);
Определить имя файла по координатам плитки.

    Point<int> google::lonlat2xy(int google_scale, Point<double> lonlat);
    Rect<int> lonlat2xy(int google_scale, Rect<double> lonlat){

Пересчет геодезических координат точки или прямоугольника в координаты
картинки google. Диапазон координат: 0..2**(google_scale-1)*256-1

    int load_to_image(
	const std::string & dir,
	int google_scale,
	Rect<int> src_rect,
	Image<int> & image,
	Rect<int> dst_rect
    );
    int load_to_image(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect,
        Image<int> & image, 
	const Rect<int> & dst_rect
    );

Загрузить прямоугольную область в прямоугольную область картинки.
Лишние данные по возможности не читаются и не сохраняются, время и
память экономятся. Используется возможность библиотеки libjpeg быстро
читать файлы, уменьшенные в 2,4,8 раз. Никакой интерполяции нет.

Область задается в координатах картинки google или в геодезических
координатах wgs84.

    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<int> & src_rect, 
	int scale=1
    );
    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect, 
	int scale=1
    );

Создать новую картинку и загрузить в нее некоторую область, уменьшенную в
scale раз.

Область задается в координатах картинки google или в геодезических
координатах wgs84.

struct google::points
Класс для организации произвольного доступа к данным с кэшированием

    google::points(
	std::string dir, 
	int google_scale, 
	int cache_size=200
    );

    int google::points::get(Point<int> p);
    int get(Point<double> p);

Получить цвет точки с заданными координатами картинки google или wgs84.

TODO
 - автоматическое скачивание

==================================================================


TODO
 - чтение/запись png
 - чтение hgt
 - srtm.h
 - геодезические преобразования
 - преобразования картинок
 - класс многоугольников
 - автоматическое определение формата картинки при чтении
 - Layer, умеющий загружать картинки в нужной проекции.
 

=============
Viewer-Workplane-Layer

- viewer - gtk-widget, который знает и показывает только workplane