В этой директории находятся разные небольшие библиотеки 
нижнего уровня: работа с точками, с цветом, с картинками, с геоданными и т.п.

cache.h -- кэш
    пришло из viewer/cache.h
    Без изменений.

point.h -- точка на плоскости (сложение/вычитание, умножение на число, сравнение и т.п.)
    То, что раньше находилось в трех местах:
    viewer/pointrect.h
    srtm02/point.h
    io_new/geo_m.h  g_point
    наверное, и вместо comparable_pair надо использовать Point...

rect.h -- прямоугольники
    пришло из viewer/pointrect.h

pointset.h -- работа с множествами точек, с границами
    пришло из srtm02/point.h
пока не готово!!!

color.h -- цвет 
    То, что раньше находилось в 
    image-gdk/image.h
    srtm02/color.h
Два класса: RGB и RGBA, которые можно (кажется) свободно 
преобразовывать друг в друга и в int.
TODO сложение и умножение на число??

rainbow.h -- радуга и пр. цветовые градиенты
    из srtm02/color.h

image.h -- картинка с окном и с настоящим memory management'ом!.
    там в начале все написано...

    Вообще, кажется, что окно будет не нужно, когда мы научимся грузить часть картинки.
    Пока пусть будет для проверки...
    
    Кстати, красивая идея делать Image<RGB> не слишком хороша из-за скорости --
    работа с Image<int> вдвое быстрее...

image_io.h -- чтение/запись картинок в файл
пока не готово!!!


==================================================================
    Работа с картинками
==================================================================
#include "image_io_tiff.h"

Чтение и запись TIFF-файлов, с помощью библиотеки libtiff

    Point<int> tiff_image::size(const char *file);

Определить размер файла. Если файл не TIFF - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалась возвращалось Point<int>(0,0)).

    int tiff_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Никакой интерполяции по этой причине нет.

Используется возможность произвольного доступа к строкам в файлах без
паковки (TIFFTAG_COMPRESSION==COMPRESSION_NONE) или с отдельной
паковкой каждой строчки (TIFFTAG_ROWSPERSTRIP==1). Работа с такими
файлами (вырезание куска, сильное уменьшение) должна быть более
быстрой.

Данные (цветные и ч/б, с прозрачностью и без) читаются в Image<int> в
формате RRGGBBAA.

    Image<int> tiff_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int tiff_image::wsave(
	const char *file, 
	const Image<int> & im, 
	bool usealpha = false
    );
    int tiff_image::save(
	const char * file, 
	const Image<int> & im, 
	bool usealpha = false
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB, в зависимости от параметра usealpha - с
прозрачностью или без. TIFFTAG_COMPRESSION всегда COMPRESSION_LZW,
паковка строчек - отдельная (что убыстряет чтение таких файлов
см.выше).

TODO
    - обработка ошибок

==================================================================
#include <image_io_jpeg.h>

Чтение и запись JPEG-файлов, с помощью библиотеки libjpeg

    Point<int> jpeg_image::size(const char *file);

Определить размер файла. Если файл не JPEG - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалось Point<int>(0,0)).


    int jpeg_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Используется возможность библиотеки libjpeg
быстро читать файлы, уменьшенные в 2,4,8 раз.  Никакой интерполяции
нет.

Данные (цветные и ч/б) читаются в Image<int> в формате RRGGBB00.

    Image<int> jpeg_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int jpeg_image::wsave(
	const char *file, 
	const Image<int> & im, 
	int quality=75
    );
    int jpeg_image::save(
	const char * file, 
	const Image<int> & im, 
	int quality=75
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB с качеством quality (0..100)

TODO
    - обработка ошибок

==================================================================
#include "google.h"

Работа с космоснимками, скачанными с maps.google.com.

Такие картинки имеют равноугольмую продольно-цилиндрическую проекцию
(mercator), и существуют в разных масштабах (1..18). В масштабе 1 весь
Земной шар изображается на одной плитке 256х256 точек. В масштабе
N вся картинка состоит из 2**(N-1)x2**(N-1) плиток 256х256.

Таким образом, при переходе к более крупному масштабу, каждая плитка
делится на 4 части. Части обозначаются буквами q, r, t, s. Исходная
плитка обозначается буквой t.  Адрес некоторой плитки записывается
строчкой из букв, например "tqqrtrssr".

    std::string google::tile2addr(int google_scale, int xt, int yt);

Определить адрес плитки по ее координатам.
Координаты считаются от левого-нижнего угла картинки и должны быть 
в диапазоне 0..2**(google_scale-1)-1.

Скачать такой кусочек можно командой:
wget http://kh<случайное число 0..2>.google.com/kh?n=404&v=9&t=<адрес плитки>

Считается, что локально такие файлы разложены по масштабам в
разные директории:
01/t.jpg
02/tq.jpg
02/tr.jpg
02/ts.jpg
02/tt.jpg
и т.д.

std::string google::tile2file(int google_scale, int xt, int yt);
Определить имя файла по координатам плитки.

    Point<int> google::lonlat2xy(int google_scale, Point<double> lonlat);
    Rect<int> lonlat2xy(int google_scale, Rect<double> lonlat){

Пересчет геодезических координат точки или прямоугольника в координаты
картинки google. Диапазон координат: 0..2**(google_scale-1)*256-1

    int load_to_image(
	const std::string & dir,
	int google_scale,
	Rect<int> src_rect,
	Image<int> & image,
	Rect<int> dst_rect
    );
    int load_to_image(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect,
        Image<int> & image, 
	const Rect<int> & dst_rect
    );

Загрузить прямоугольную область в прямоугольную область картинки.
Лишние данные по возможности не читаются и не сохраняются, время и
память экономятся. Используется возможность библиотеки libjpeg быстро
читать файлы, уменьшенные в 2,4,8 раз. Никакой интерполяции нет.

Область задается в координатах картинки google или в геодезических
координатах wgs84.

    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<int> & src_rect, 
	int scale=1
    );
    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect, 
	int scale=1
    );

Создать новую картинку и загрузить в нее некоторую область, уменьшенную в
scale раз.

Область задается в координатах картинки google или в геодезических
координатах wgs84.

struct google::points
Класс для организации произвольного доступа к данным с кэшированием

    google::points(
	std::string dir, 
	int google_scale, 
	int cache_size=200
    );

    int google::points::get(Point<int> p);
    int get(Point<double> p);

Получить цвет точки с заданными координатами картинки google или wgs84.

TODO
 - автоматическое скачивание

==================================================================


TODO
 - чтение/запись png
 - чтение hgt
 - srtm.h
 - геодезические преобразования
 - преобразования картинок
 - класс многоугольников
 - автоматическое определение формата картинки при чтении
 - Layer, умеющий загружать картинки в нужной проекции.
 
