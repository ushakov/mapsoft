Уже готовые программы:


======================================================================
fig2pnm <file.fig> > out.pnm

Изготовление растровой карты из fig. Программа никак не связана с хранилищем
карт, не использует никаких библиотек. Может быть применена на любых fig-
файлах...

Отдельно запускаются 4 процесса, выдающие растр для 4 диапазонов слоев:
41:400 - основа карты
40     - подписи (под подписями стираются темные линии на карте и сетка)
35:39  - сетка (рисуется полупрозрачно)
30:34  - легенда (рисуется поверх всего)

Пример такого процесса:
fig2dev -Lppm -j -F -m3.75 -g#FDFDFD -D+35:39 <file.fig>

Данные читаются в узкую полосу шириной в изображение и по мере чтения
прокручиваются по этой полосе, так что программа обработки может
иметь доступ к нескольким соседним строкам.

Параметры:
 r1 (размер светлой полосы вокруг текста),
 r2 (радиус поиска при закраске темных точек),
 thr величина порога r+g+c, ниже которого точки считаются темными
 ширина полосы данных = 2*(r1+r2)+1.
 #FDFDFD - прозрачный цвет

Стирание темных линий под текстом происходит следующим образом:  для
каждой точки из слоя текста строится окрестность радиуса r1, в ней
находятся темные точки (r+g+b < thr). Для темной точки ищется
ближайшая светлая точка из слоя карты в окрестности r2, ее цветом и
закрашивается темная точка (если в окрестности нет светлых точек -
темная точка закрашивается белым). Кроме того, во всей окрестности
точки текста радиуса r1 делаются прозрачними точки в слое сетки.

======================================================================
get_legend <conf_file> > out.fig

Получить fig-картинку с условными знаками. Знаки имеют ключи, так что
картинку можно преобразовать в печатный вид программой get_print.
Картинка не имеет привязки (TODO: а надо ли?)

======================================================================
get_map <map> <conf_file> <out.fig|out.mp>

Получить из хранилища карт копию для редактирования в формате 
fig или mp, в соответствии с конф.файлом conf_file.
Почти все параметры картографических объектов устанавливаются
в зависимости от их ключа.

======================================================================

./make_map_gk <map name> <scale, m/cm> <lon0> <x1> <x2> <y1> <y2>

-- Сделать заготовку карты с нужными параметрами.
   Проекция Г-К, СК Пулково-42

======================================================================
./update_map <map> <source> <conf_file> <file.mp|file.fig> <nc.fig>

-- обновить карту из mp или fig-файла 

Программа всасывает в систему карту с именем map, и именем источника source
(надо сюда писать свое имя :)) в соответствии с конфигурационным 
файлом conf_file. Из файла file.mp или file.fig. 
Все, что не удалось преобразовать сваливается в nc.fig.

Два обновления одной и той же картой не приводят ни к каким изменениям,
кроме других id новых объектов.

======================================================================
./get_map <map> <conf_file> <file.mp|file.fig>


============================================================

============================================================

    Хранилище карт

В системе имеется внутреннее хранилище карт. Карты хранятся в формате
xfig, но они не должны редактироваться напрямую, а должны помещаться в
хранилище, и обновляться специальными программами...

Действия с хранилищем могут быть такие:
* создать карту
* получить карту из хранилища для редактирования в формате fig или mp
* внести исправления в хранилище из отредактированной карты
* получить табличку условных обозначений в виде fig или как-то еще
* получить версию карты для печати/публикации
* обновить карту из внешнего источника
(сейчас четыре первых операции более-менее сделаны, остальные надеюсь 
сделать довольно быстро)


    Объекты на карте

Карта состоит из картографических объектов, подписей к ним, разных пометок,
часть из которых мы хотим печатать, а часть - не хотим...
Для разных типов объектов в fig-файле зарезервированы разные глубины:

50-399 -- картографические объекты. Если вы нарисуете в карте объект
такой глубины, система будет пытаться понять, какому условному
обозначению он соответствует, и будет ругаться в случае неудачи. Если вы
ничего такого не имеете в виду -- рисуйте в других слоях. Здесь же
лежат подписи к объекту. Они обязательно должны иметь специальный ключ,
в котором записано, к какому объекту относятся. Подписи создаются
автоматически при помещении объекта в карты, а потом могут всячески
редактироваться пользователем.

Объекты на остальных глубинах -- некартографические. Обычно на глубине
1 лежит привязка карты, в глубины 5-7 программа mapsoft_add2fig
добавляет точки и треки, в глубины больше 400 удобно класть растровые
исходники для карты...

При изготовлении печатной версии карты разные глубины могут обрабатываться
по-разному.

40-44  -- сетка. Эти объекты рисуются на карте для печати, причем
когда-нибудь хочется сделать, чтоб печатались они в полупрозрачном виде.

30-39  -- печатные пометки (легенда и т.п.).  Эти объекты рисуются на
карте для печати поверх сетки.

Остальные некартографические объекты при печати исчезают..


    Система условных обозначений

Принятая система условных обозначений читается из специального
конфигурационного файла. Конфигурационный файл записан в формате YAML и
должен содержать список таких объектов:

  name: <название объекта>
  desc: <подробное описание объекта>
  mp:   <маска для тестового mp-объекта>
  fig:  <маска для тестового fig-объекта>
  txt:  <маска fig-объекта для подписи>
  pic:  <имя fig-файла с картинкой>

(Обратите внимание, что пользовательские цвета в fig-заголовке
даны в виде числа 0x1RRGGBB в десятичном виде.)

Идентификатором условного обозначения является число - тип объекта,
равное типу тестового mp-объекта + 0x100000 для линейных объектов,
+ 0x200000 для площадных объектов.

При помещении нового объекта в карту, система пытается  понять, какому
условному обозначению он соответствует. Для этого новый объект
сравнивается c тестовым следующим образом:

- если объект - текст, то должны совпасть глубина, цвет и шрифт.

- если объект - точка, то должны совпасть глубина, толщина, цвет и округлость
  (-- с округлостью пока проблемы, кажется --)

- если объект - линия, то должны совпасть толщина, глубина, тип заливки,
  если толщина не 0, то, кроме того, цвет и тип линии, если заливка не
  прозрачная - то цвет заливки, если заливка штриховая - то цвет линии (даже
  если толщина линии 0).

В результате таких сравнений определяется тип объекта.
см. int zn_conv::get_type (const fig::fig_object & o);

Внутри системы объект идентифицируется только по типу, его параметры
вроде цвета, глубины и т.п. не важны. Поэтому можно, например, двум
людям иметь два разных конфигурационных файла (один рисует дороги
синим цветом, а другой - черным) и получать для редактирования или
обновлять карту в соответствии со своей конфигурацией.


    Ключ картографического объекта

При помещении в хранилище каждый картографический объект 
получает уникальный ключ такого вида:

<тип> <дата> <время> <id>@<map> [[<sid>@]source]

* тип объекта
* дата вида 2007-12-03
* время вида 15:26:16
* id - уникальный номер объекта в карте
* map - название карты
* sid - уникальный номер объекта в источнике (нужен, чтобы 
  автоматически обновлять карту из этого источника)
* source - название источника

В fig-объекте ключ записывается во второй строчке комментария 
(в первой строчке - название объекта)
В mp-объекте ключ записывается в первой строчке комментария.

Тип mp-объекта всегда определяется по его mp-типу,
а не по ключу.

Тип fig-объекта, имеющего ключ определяется по ключу.
Так что, даже если перекрасить, например, овраг под дорогу,
то он оврагом и останется...



    Подписи и привязанные объекты

Любой некартографический объект может быть привязан к картографическому.
Для этого в него записывается (во 2 строку комментария к fig-объекту) 
ключ специального вида, в котором записан id объекта к которому наш объект
привязан:

+<id>@<map>

Например, с таким ключом создаются все автоматические подписи...

Что означает, что объект A привязан к объекту B:
* если B удалят, то и A исчезнет.
-- остальное не сделано, и непонятно, как надо
* если B.comment[0] изменится, то A.text тоже изменится
* если точка привязки подписи B сдвинется, то и A сдвинется
  (это можно делать только при обновлении из mp)  

Подписи автоматически создаются только при добавлении нового объекта.
Если вы хотите автоматически создать подпись заново -  сотрите ключ
объекта.

    
    Разные странные параметры

При выдаче карты из хранилища, почти все параметры знака
устанавливаются  в соответствии с конфигурационным файлом. Но часть
параметров сохраняется: сплайн это или ломаная,  замкнутая линия или
не замкнутая, наличие стрелок и их параметры, наклон текста.


=============================


_Тип объекта в хранилище карт определяется только ключом, вне
хранилища - только внешним видом!_

(в хранилище еще живет информация: сплайн или ломаная,  замкнутая
линия или не замкнутая, наличие стрелок и их параметры, наклон текста)

Тип в ключе снаружи хранилища не нужен! (убрать что ли :))

    Процедура обновления:

Все некартографические объекты и подписи при обновлении из fig берутся
только из нового файла, при обновлении из mp - только из старого
файла.

    Что нам интересно:

 новые:           fig  mp
картогр.объекты   +    +
подписи           +    -
прочие объекты    +    -
 старые:
картогр.объекты   +    +
подписи           -    +
прочие объекты    -    +

multimap<int, fig> new_objects; // по типу
map<int, fig> old_objects;      // по id
multimap<int, fig> labels;      // по id объекта

//параметры, которые нам хочется сравнивать и менять
параметры объекта:
  тип
  время изменения
  текст
  координаты
параметры подписи:
  координаты
  текст
  (внешний вид?)

Сперва мы разбираемся с объектами:

Есть старый объект
    Старый объект имеет более новое время -- использовать старый объект вместо нового.
    Старый объект был удален -- не записывать ничего
    Старый объект имеет другой тип или координаты, или текст - обновить время в новом объекте
    Записать новый объект
Нет старого объекта

Текст подписи не совпадает с текстом объекта - поменять текст подписи.


Стиль подписи устанавливать по объекту при получении карты!

======================================================================

Обновление из другой карты

Пусть у нас есть две карты: map1 и map2. Пусть в карте map2 мы хотим
использовать все объекты карты map1 (может быть, обрезав их по
границам карты) и обновлять из нее. Также мы хотим использовать в
карте map2 и другие объекты...

Примеры, для чего это может быть полезно: склейки карт на уровне
вектора, или наоборот, использование маленького кусочка карты с другим
оформлением, положением подписей; добавление в карту объектов из
внешнего источника (каталога перевалов, например)

Процедура обновления происходит почти так же, как при обновлении из
mp-файла (то есть, подписи всегда берутся старые!), однако при
сравнении рассматриваются только объекты из map2 у которых есть ключ,
объекты из map1 у которых source = map2 и source_id = id в карте map2. 
Остальные объекты и подписи к ним из map1 записываются без изменений...

