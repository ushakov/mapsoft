Уже готовый программы:

./make_map_gk <map name> <scale, m/cm> <lon0> <x1> <x2> <y1> <y2>

-- Сделать заготовку карты с нужными параметрами.
   Проекция Г-К, СК Пулково-42

./update_map <map> <source> <conf_file> <file.mp|file.fig> <nc.fig>

-- обновить карту из mp или fig-файла 

Программа всасывает в систему карту с именем map, и именем источника source
(надо сюда писать свое имя :)) в соответствии с конфигурационным 
файлом conf_file. Из файла file.mp или file.fig. 
Все, что не удалось преобразовать сваливается в nc.fig.

Два обновления одной и той же картой не приводят ни к каким изменениям,
кроме других id новых объектов.

./get_map <map> <conf_file> <file.mp|file.fig>


============================================================

============================================================

    Хранилище карт

В системе имеется внутреннее хранилище карт. Карты хранятся в формате
xfig, но они не должны редактироваться напрямую, а должны помещаться в
хранилище, и обновляться специальными программами...

Действия с хранилищем могут быть такие:
* создать карту
* получить карту из хранилища для редактирования в формате fig или mp
* внести исправления в хранилище из отредактированной карты
* получить табличку условных обозначений в виде fig или как-то еще
* получить версию карты для печати/публикации
* обновить карту из внешнего источника
(сейчас четыре первых операции более-менее сделаны, остальные надеюсь 
сделать довольно быстро)


    Объекты на карте

Карта состоит из картографических объектов, подписей к ним, разных пометок,
часть из которых мы хотим печатать, а часть - не хотим...
Для разных типов объектов в fig-файле зарезервированы разные глубины:

50-399 -- картографические объекты. Если вы нарисуете в карте объект
такой глубины, система будет пытаться понять, какому условному
обозначению он соответствует, и будет ругаться в случае неудачи. Если вы
ничего такого не имеете в виду -- рисуйте в других слоях. Здесь же
лежат подписи к объекту. Они обязательно должны иметь специальный ключ,
в котором записано, к какому объекту относятся. Подписи создаются
автоматически при помещении объекта в карты, а потом могут всячески
редактироваться пользователем.

Объекты на остальных глубинах -- некартографические. Обычно на глубине
1 лежит привязка карты, в глубины 5-7 программа mapsoft_add2fig
добавляет точки и треки, в глубины больше 400 удобно класть растровые
исходники для карты...

При изготовлении печатной версии карты разные глубины могут обрабатываться
по-разному.

40-44  -- сетка. Эти объекты рисуются на карте для печати, причем
когда-нибудь хочется сделать, чтоб печатались они в полупрозрачном виде.

30-39  -- печатные пометки (легенда и т.п.).  Эти объекты рисуются на
карте для печати поверх сетки.

Остальные некартографические объекты при печати исчезают..


    Система условных обозначений

Принятая система условных обозначений читается из специального
конфигурационного файла. Конфигурационный файл записан в формате YAML и
должен содержать список таких объектов:

  name: <название объекта>
  desc: <подробное описание объекта>
  mp:   <маска для тестового mp-объекта>
  fig:  <маска для тестового fig-объекта>
  txt:  <маска fig-объекта для подписи>
  pic:  <имя fig-файла с картинкой>

(Обратите внимание, что пользовательские цвета в fig-заголовке
даны в виде числа 0x1RRGGBB в десятичном виде.)

Идентификатором условного обозначения является число - тип объекта,
равное типу тестового mp-объекта + 0x100000 для линейных объектов,
+ 0x200000 для площадных объектов.

При помещении нового объекта в карту, система пытается  понять, какому
условному обозначению он соответствует. Для этого новый объект
сравнивается c тестовым следующим образом:

- если объект - текст, то должны совпасть глубина, цвет и шрифт.

- если объект - точка, то должны совпасть глубина, толщина, цвет и округлость
  (-- с округлостью пока проблемы, кажется --)

- если объект - линия, то должны совпасть толщина, глубина, тип заливки,
  если толщина не 0, то, кроме того, цвет и тип линии, если заливка не
  прозрачная - то цвет заливки, если заливка штриховая - то цвет линии (даже
  если толщина линии 0).

В результате таких сравнений определяется тип объекта.
см. int zn_conv::get_type (const fig::fig_object & o);

Внутри системы объект идентифицируется только по типу, его параметры
вроде цвета, глубины и т.п. не важны. Поэтому можно, например, двум
людям иметь два разных конфигурационных файла (один рисует дороги
синим цветом, а другой - черным) и получать для редактирования или
обновлять карту в соответствии со своей конфигурацией.


    Ключ картографического объекта

При помещении в хранилище каждый картографический объект 
получает уникальный ключ такого вида:

<тип> <дата> <время> <id>@<map> [[<sid>@]source]

* тип объекта
* дата вида 2007-12-03
* время вида 15:26:16
* id - уникальный номер объекта в карте
* map - название карты
* sid - уникальный номер объекта в источнике (нужен, чтобы 
  автоматически обновлять карту из этого источника)
* source - название источника

В fig-объекте ключ записывается во второй строчке комментария 
(в первой строчке - название объекта)
В mp-объекте ключ записывается в первой строчке комментария.

Тип mp-объекта всегда определяется по его mp-типу,
а не по ключу.

Тип fig-объекта, имеющего ключ определяется по ключу.
Так что, даже если перекрасить, например, овраг под дорогу,
то он оврагом и останется...



    Подписи и привязанные объекты

Любой некартографический объект может быть привязан к картографическому.
Для этого в него записывается (во 2 строку комментария к fig-объекту) 
ключ специального вида, в котором записан id объекта к которому наш объект
привязан:

+<id>@<map>

Например, с таким ключом создаются все автоматические подписи...

Что означает, что объект A привязан к объекту B:
* если B удалят, то и A исчезнет.
-- остальное не сделано, и непонятно, как надо
* если B.comment[0] изменится, то A.text тоже изменится
* если точка привязки подписи B сдвинется, то и A сдвинется
  (это можно делать только при обновлении из mp)  

Подписи автоматически создаются только при добавлении нового объекта.
Если вы хотите автоматически создать подпись заново -  сотрите ключ
объекта.





