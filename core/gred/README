    Универсальный графический редактор

===========================================================================

Мы хотим работать со множеством разнородных графических объектов, каждый
из которых может быть как-то нарисован на растровой плоскости. (Объекты
распределены по глубинам), способ рисования объекта определяется его
классом. Масштаб и геодезическая привязка плоскости является некоторой
дополнительной информацией, которую некоторые объекты могут
использовать.

Плоскость может быть разбита на плитки, чтоб удобно было кэшировать
данные. Каждая плитка знает, какие объекты на ней нарисованы (чтоб
быстро уметь перерисовываться, не перебирая все объекты).

Объекты должны кэшировать информацию, необходимую для отрисовки на плитках.
Вид кэша - на усмотрение класса объекта.

При изменении одного объекта мы получаем диапазон плиток, которые нам
надо перерисовать. При перерисовке данные для других объектов будут
извлечены из их кэша.

===========================================================================
    1. Графический объект  -- GObj -- <iface/gobj.h>

Абстрактный интерфейс графического объекта. Единственный неопределенный метод:

    int draw(iImage &img, const iPoint &origin);

-- рисование на картинке img со смещением origin. Должен возвращать
одно из следующих значений:
GOBJ_FILL_NONE  -- ничего не было нариовано
GOBJ_FILL_PART  -- что-то было нарисовано
GOBJ_FILL_ALL   -- все изображение было зарисовано непрозрачным цветом

    iRect range(void) const;

-- метод должен возвращать диапазон координат объекта. По умолчанию
возвращается значение GOBJ_MAX_RANGE, соответствующее диапазону координат
INT_MIN/2 ... INT_MAX/2. (Такой диапазон выбран, чтобы разность двух
координат всегда укладывается в тип int).

    void set_scale(const double k);

-- метод, вызывается при установке масштаба k. По умолчанию не делает ничего.

    void set_conv(const Conv & cnv);

-- метод, вызывается при установке преобразования. По умолчанию не делает
ничего. Пока не используется!

  bool is_gray();
  void gray_on();
  void gray_off();

-- методы для работы с "серым режимом". В этом режиме объект должен рисовать
только серые контуры.

-- Важно: draw() может вызываться из второго потока. Объект должен иметь
свой mutex и блокировать draw() при изменениях данных.

===========================================================================

    1.1. Примеры графических объектов

GObjSolidFill
GObjTestGrid
GObjTestTile
GObjLine
Workplane    -- из старого вьюера

===========================================================================

===========================================================================

    4. ActionManager -- action_manager.h

Добавление "действий" к объекту типа Viewer.

===========================================================================
    4. Вьюер с действиями (ActionViewer<ViewerT>)

В файле action.h описан интерфейс объекта-действия:

virtual std::string get_name(); // вернуть название действия (пока не используется)
virtual void init();            // начать действие
virtual void reset();           // прервать действие
virtual void click(const iPoint & p, const Gdk::ModifierType & state);
  // обработать нажатие кнопки мыши.

В файле action_viewer.h описан класс, добавляющий к любому вьюеру действия.

ActionViewer<MyViewer> V(plane); // создать вьюер с действиями на основе MyViewer
V.action_add(Action * a); //
V.action_clear();         // удалить все действия
V.action_select(int a);   // прервать текущее действие и выбрать новое

===========================================================================




    6. Графический объект (GObject) -- TODO

Объект, умеющий нарисоваться на растровой картинке.

Получает картинку, ее координаты на растровой плоскости,
и информацию о привязки и масштабе растровой плоскости.
Рисует что-то на картинке. Что-то в таком духе:
int GObject::draw(GImage & img, const GPoint & origin, const GObjInfo & info);

GObjInfo -- информация о привязке и масштабе. Объект может использовать или
не использовать ее по своему усмотрению.
(jpeg-картинка может эффективно грузиться с уменьшением,
иконка может вообще игнорировать масштаб/привязку...)

Объект может (и должен) кэшировать информацию, нужную для рисования
определенной области. Формат данных в кэше - на усмотрение объекта: это может
быть набор точек для рисования линии или преобразованная растровая картинка.

Объект может отдавать "сложность" кэширования и рисования.
Это хочется применять для умного разбиения плоскости на плитки в зависимости от
сложности рисования объектов на плитках. Полезность этого пока
непонятна.

Объект может предоставлять функции поиска (ткнули в такую-то точку - вернули
объект или точку объекта, или сегмент объекта или т.п.).


