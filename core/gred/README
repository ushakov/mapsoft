    Универсальный графический редактор

===========================================================================

Мы хотим работать со множеством разнородных графических объектов, каждый
из которых может быть как-то нарисован на растровой плоскости. (Объекты
распределены по глубинам), способ рисования объекта определяется его
классом. Масштаб и геодезическая привязка плоскости является некоторой
дополнительной информацией, которую некоторые объекты могут
использовать.

Плоскость может быть разбита на плитки, чтоб удобно было кэшировать
данные. Каждая плитка знает, какие объекты на ней нарисованы (чтоб
быстро уметь перерисовываться, не перебирая все объекты).

Объекты должны кэшировать информацию, необходимую для отрисовки на плитках.
Вид кэша - на усмотрение класса объекта.

При изменении одного объекта мы получаем диапазон плиток, которые нам
надо перерисовать. При перерисовке данные для других объектов будут
извлечены из их кэша.

===========================================================================
    1. Графический объект  -- GObj -- <iface/gobj.h>

Абстрактный интерфейс графического объекта. Единственный неопределенный метод:

    int draw(iImage &img, const iPoint &origin);

-- рисование на картинке img со смещением origin. Должен возвращать
одно из следующих значений:
GOBJ_FILL_NONE  -- ничего не было нариовано
GOBJ_FILL_PART  -- что-то было нарисовано
GOBJ_FILL_ALL   -- все изображение было зарисовано непрозрачным цветом

    iRect range(void) const;

-- метод должен возвращать диапазон координат объекта. По умолчанию
возвращается значение GOBJ_MAX_RANGE, соответствующее диапазону координат
INT_MIN/2 ... INT_MAX/2. (Такой диапазон выбран, чтобы разность двух
координат всегда укладывается в тип int).

    void set_scale(const double k);

-- метод, вызывается при установке масштаба k. По умолчанию не делает ничего.

    void set_conv(const Conv & cnv);

-- метод, вызывается при установке преобразования. По умолчанию не делает
ничего. Пока не используется!

  bool is_gray();
  void gray_on();
  void gray_off();

-- методы для работы с "серым режимом". В этом режиме объект должен рисовать
только серые контуры.

===========================================================================

    1.1. Примеры графических объектов

GObjSolidFill
GObjTestGrid
GObjTestTile
GObjLine
Workplane    -- из старого вьюера

===========================================================================

    2. Вьюеры

===========================================================================
    2.1 Viewer -- <iface/Viewer.h>

Интерфейс для использования в rubber и action_manager...
Можно бы и удалить, пока у нас нет вьюеров, основанных не на SimpleViewer.

===========================================================================

    2.2. SimpleViewer (simple_viewer.h)

Простейший GTK-вьюер графического объекта. Позволяет таскать объект по
экрану, перемасштабировать его... По expose_event необходимые части объекта
перерисовываются. Этот вьюер подходит только для быстро рисующихся объектов!

    SimpleViewer V();            // Простой вьюер без объекта
    SimpleViewer V(&obj);        // Простой вьюер для указанного объекта

    iPoint pt = V.get_origin();  // Получить положение окна
    V.set_origin(pt);            // Установить новое положение окна

    GObj * o = V.get_obj();      // Получить ссылку на объект
    V.set_obj(&obj);             // Заменить ссылку на объект

    int c = V.get_bgcolor();     // Получить цвет фона
    V.set_bgcolor (c);           // Установить цвет фона

    V.redraw();                  // Перерисовать экран

    V.rescale(1.5);              // Увеличить масштаб в 1.5 раза
    V.set_scale(1.5);            // Установить масштаб 1.5
    double sc=V.get_scale();     // Получить масштаб

Прочие функции:

Находится ли вьюер в состоянии прокрутки. Используются, например,
при рисовании "резиновых линий":

    virtual bool is_on_drag();

Управление счетчиком эпохи. Используется в более сложных многопоточных
вьюерах, чтобы показать второй нити, что ситуация изменилась и нужно
все перерисовать заново:

    virtual int  get_epoch();
    virtual void inc_epoch();

Сигналы, испускаемые вьюером до и после каждого рисования на экране.

    sigc::signal<void> & signal_before_draw();
    sigc::signal<void> & signal_after_draw();

===========================================================================

    2.3. MThreadViewer -- mthread_viewer.h

Многопотоковый вьюер, более удобный для медленных объектов.
По expose_event нужная область быстро закрашивается фоновым цветом,
после этого запускается отдельный поток, готовящий картинку из
"медленного" объекта. По мере готовности картинка дорисовывается.

    MThreadViewer V(&obj);

Недостатки MThreadViewer:

* плитки большого размера могут рисоваться долго. Красивее рисовать
  все небольшими плитками одинакового размера раз в секунду
* не подходит для объектов, которые кэшируют информацию, относящуюся
  к запрошенным плиткам (а такие объекты мы и собираемся дальше делать)

Тупиковый объект, вряд ли его надо использовать.

===========================================================================

    2.3. DThreadViewer -- dthread_viewer.h

Двухпотоковый вьюер с квадратными плитками.

    DThreadViewer V(&obj);

Методы те же, что и у SimpleViewer.

===========================================================================

    3. Резиновые линии  -- Rubber -- rubber.h

Добавление "резиновых линий" к объекту типа Viewer.

Резиновые линии рисуются поверх всех объектов. Они могут быть
привязаны к объекту или к мыши.

Сегмент резиновой линии - это пара точек и флаги привязки:

    RubberSegment rs((iPoint)p1, (iPoint)p2, (rubbfl_t)flags);

флаг привязки:
бит 1 - координата X точки 1 привязана к мыши
бит 2 - координата Y точки 1 привязана к мыши
бит 3 - координата X точки 1 привязана к мыши
бит 4 - координата Y точки 1 привязана к мыши
биты 5-8 - тип сегмента (отрезок, эллипс, окружность)
бит 9 - флаг, показывающий, нарисован ли в данный момент сегмент

Маски:
RUBBFL_PLANE     0x0 -- обе точки привязаны к плоскости
RUBBFL_MOUSE_P1X 0x1 -- координата X точки 1 привязана к мыши
RUBBFL_MOUSE_P1Y 0x2 -- координата Y точки 1 привязана к мыши
RUBBFL_MOUSE_P2X 0x4 -- координата X точки 2 привязана к мыши
RUBBFL_MOUSE_P2Y 0x8 -- координата Y точки 2 привязана к мыши
RUBBFL_MOUSE_P1  0x3 -- точка 1 привязана к мыши
RUBBFL_MOUSE_P2  0xC -- точка 2 привязана к мыши
RUBBFL_MOUSE     0xF -- обе точки привязаны к мыши

RUBBFL_TYPEMASK  0xF0 -- маска типа сегмента
RUBBFL_LINE      0x00 -- сегмент является отрезком
RUBBFL_ELL       0x10 -- эллипс, заданный диагональю описанного прямоугольника
RUBBFL_ELLC      0x20 -- эллипс, заданный полудиагональю оп. прямоугольника
RUBBFL_CIRC      0x30 -- окружность, заданная диаметром
RUBBFL_CIRCC     0x40 -- окружность, заданная радиусом

RUBBFL_DRAWN    0x100 -- сегмент нарисован

При создании объекту класса Rubber дается ссылка на Viewer:

    Rubber(Viewer * v)

Добавление сегмента:
  void add(rs);
  void add(p1, p2, flags);
  void add(x1, y1, x2, y2, flags);

  rs = pop();  // удалить последний сегмент и вернуть его
  rs = get();  // получить последний сегмент

  clear();      // удалить все сегменты
  dump();       // вывести все сегменты на stderr
  i = size();   // получить количество сегментов

Модификация координат, привязанных к объекту:
  Rubber & operator/= (double k);
  Rubber & operator*= (double k);

Высокоуровневые функции для добавления сегментов:
  add_src_sq(p, size);
  add_dst_sq(size);
  add_diag(p);
  add_rect(p);
  add_ell(p);
  add_ellc(p);
  add_circ(p);
  add_circc(p);

Несколько объектов типа Rubber хорошо уживаются на одном Viewer'е.

===========================================================================

    4. ActionManager -- action_manager.h

Добавление "действий" к объекту типа Viewer.

===========================================================================
    4. Вьюер с действиями (ActionViewer<ViewerT>)

В файле action.h описан интерфейс объекта-действия:

virtual std::string get_name(); // вернуть название действия (пока не используется)
virtual void init();            // начать действие
virtual void reset();           // прервать действие
virtual void click(const iPoint & p, const Gdk::ModifierType & state);
  // обработать нажатие кнопки мыши.

В файле action_viewer.h описан класс, добавляющий к любому вьюеру действия.

ActionViewer<MyViewer> V(plane); // создать вьюер с действиями на основе MyViewer
V.action_add(Action * a); //
V.action_clear();         // удалить все действия
V.action_select(int a);   // прервать текущее действие и выбрать новое

===========================================================================




    6. Графический объект (GObject) -- TODO

Объект, умеющий нарисоваться на растровой картинке.

Получает картинку, ее координаты на растровой плоскости,
и информацию о привязки и масштабе растровой плоскости.
Рисует что-то на картинке. Что-то в таком духе:
int GObject::draw(GImage & img, const GPoint & origin, const GObjInfo & info);

GObjInfo -- информация о привязке и масштабе. Объект может использовать или
не использовать ее по своему усмотрению.
(jpeg-картинка может эффективно грузиться с уменьшением,
иконка может вообще игнорировать масштаб/привязку...)

Объект может (и должен) кэшировать информацию, нужную для рисования
определенной области. Формат данных в кэше - на усмотрение объекта: это может
быть набор точек для рисования линии или преобразованная растровая картинка.

Объект может отдавать "сложность" кэширования и рисования.
Это хочется применять для умного разбиения плоскости на плитки в зависимости от
сложности рисования объектов на плитках. Полезность этого пока
непонятна.

Объект может предоставлять функции поиска (ткнули в такую-то точку - вернули
объект или точку объекта, или сегмент объекта или т.п.).


