#include "image.h"

    struct Image<T>

Картинка -- двумерный массив элементов произвольного типа с
настоящим memory management'ом!.

При присвоении и инициализации из другой картинки массив данных не копируется.
(устроен счетчик ссылок на массив, когда ссылок не остается - массив удаляется)

Копирование картинки и данных: image1 = image.copy()

Доступ к точкам картинки: image.get(x,y),  image.set(x,y,c)
В функциях доступа не проверяется выход за границы картинки!
Компилить с ключом -O1 (скорость возрастет раза в три)

Размер картинки: image.w, image.h

Получить размеры окна:
    Rect<int> r = image.window_get();
Установить размеры окна
(если прямоугольник вылезает за картинку - он правильно обрезается):
    image.window_set(r);  
Установить окно во всю картинку:
    image.window_expand();

    bool empty() const;

Вообще, кажется, что окно будет не нужно, когда мы научимся грузить часть картинки.
Пока пусть будет для проверки...
    
Красивая идея делать Image<RGB> не слишком хороша из-за скорости --
работа с Image<int> вдвое быстрее...

TODO
    * может быть, убрать окно...
    * для тестовых целей сделать версии get и set с проверкой диапазона.

==================================================================
    Работа с картинками
==================================================================
#include "image_tiff.h"

Чтение и запись TIFF-файлов, с помощью библиотеки libtiff

    Point<int> tiff_image::size(const char *file);

Определить размер файла. Если файл не TIFF - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалась возвращалось Point<int>(0,0)).

    int tiff_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Никакой интерполяции по этой причине нет.

Используется возможность произвольного доступа к строкам в файлах без
паковки (TIFFTAG_COMPRESSION==COMPRESSION_NONE) или с отдельной
паковкой каждой строчки (TIFFTAG_ROWSPERSTRIP==1). Работа с такими
файлами (вырезание куска, сильное уменьшение) должна быть более
быстрой.

Данные (цветные и ч/б, с прозрачностью и без) читаются в Image<int> в
формате RRGGBBAA.

    Image<int> tiff_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int tiff_image::wsave(
	const char *file, 
	const Image<int> & im, 
	bool usealpha = false
    );
    int tiff_image::save(
	const char * file, 
	const Image<int> & im, 
	bool usealpha = false
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB, в зависимости от параметра usealpha - с
прозрачностью или без. TIFFTAG_COMPRESSION всегда COMPRESSION_LZW,
паковка строчек - отдельная (что убыстряет чтение таких файлов
см.выше).

TODO
    - обработка ошибок

==================================================================
#include <image_jpeg.h>

Чтение и запись JPEG-файлов, с помощью библиотеки libjpeg

    Point<int> jpeg_image::size(const char *file);

Определить размер файла. Если файл не JPEG - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалось Point<int>(0,0)).


    int jpeg_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Используется возможность библиотеки libjpeg
быстро читать файлы, уменьшенные в 2,4,8 раз.  Никакой интерполяции
нет.

Данные (цветные и ч/б) читаются в Image<int> в формате RRGGBB00.

    Image<int> jpeg_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int jpeg_image::wsave(
	const char *file, 
	const Image<int> & im, 
	int quality=75
    );
    int jpeg_image::save(
	const char * file, 
	const Image<int> & im, 
	int quality=75
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB с качеством quality (0..100)

TODO
    - обработка ошибок

==================================================================
