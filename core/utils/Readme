
#include "image.h"

    struct Image<T>

Картинка -- двумерный массив элементов произвольного типа с
настоящим memory management'ом!.

При присвоении и инициализации из другой картинки массив данных не копируется.
(устроен счетчик ссылок на массив, когда ссылок не остается - массив удаляется)

Копирование картинки и данных: image1 = image.copy()

Доступ к точкам картинки: image.get(x,y),  image.set(x,y,c)
В функциях доступа не проверяется выход за границы картинки!
Компилить с ключом -O1 (скорость возрастет раза в три)

Размер картинки: image.w, image.h

Получить размеры окна:
    Rect<int> r = image.window_get();
Установить размеры окна
(если прямоугольник вылезает за картинку - он правильно обрезается):
    image.window_set(r);  
Установить окно во всю картинку:
    image.window_expand();

    bool empty() const;

Вообще, кажется, что окно будет не нужно, когда мы научимся грузить часть картинки.
Пока пусть будет для проверки...
    
Красивая идея делать Image<RGB> не слишком хороша из-за скорости --
работа с Image<int> вдвое быстрее...

TODO
    * может быть, убрать окно...
    * для тестовых целей сделать версии get и set с проверкой диапазона.

==================================================================
    Работа с картинками
==================================================================
#include "image_tiff.h"

Чтение и запись TIFF-файлов, с помощью библиотеки libtiff

    Point<int> tiff_image::size(const char *file);

Определить размер файла. Если файл не TIFF - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалась возвращалось Point<int>(0,0)).

    int tiff_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Никакой интерполяции по этой причине нет.

Используется возможность произвольного доступа к строкам в файлах без
паковки (TIFFTAG_COMPRESSION==COMPRESSION_NONE) или с отдельной
паковкой каждой строчки (TIFFTAG_ROWSPERSTRIP==1). Работа с такими
файлами (вырезание куска, сильное уменьшение) должна быть более
быстрой.

Данные (цветные и ч/б, с прозрачностью и без) читаются в Image<int> в
формате RRGGBBAA.

    Image<int> tiff_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int tiff_image::wsave(
	const char *file, 
	const Image<int> & im, 
	bool usealpha = false
    );
    int tiff_image::save(
	const char * file, 
	const Image<int> & im, 
	bool usealpha = false
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB, в зависимости от параметра usealpha - с
прозрачностью или без. TIFFTAG_COMPRESSION всегда COMPRESSION_LZW,
паковка строчек - отдельная (что убыстряет чтение таких файлов
см.выше).

TODO
    - обработка ошибок

==================================================================
#include <image_jpeg.h>

Чтение и запись JPEG-файлов, с помощью библиотеки libjpeg

    Point<int> jpeg_image::size(const char *file);

Определить размер файла. Если файл не JPEG - выдается сообщение об
ошибке и программа завершает работу (TODO - сделать свою обработку
ошибок, чтобы возвращалось Point<int>(0,0)).


    int jpeg_image::load_to_image(
	const char *file, 
	Rect<int> src_rect, 
	Image<int> & image, 
	Rect<int> dst_rect
    );

Загрузить прямоугольную область из файла в прямоугольную область
картинки. Лишние данные по возможности не читаются и не сохраняются,
время и память экономятся. Используется возможность библиотеки libjpeg
быстро читать файлы, уменьшенные в 2,4,8 раз.  Никакой интерполяции
нет.

Данные (цветные и ч/б) читаются в Image<int> в формате RRGGBB00.

    Image<int> jpeg_image::load(const char *file, const int scale=1);

Создать новую картинку и загрузить в нее весь файл, уменьшенный в
scale раз.

    int jpeg_image::wsave(
	const char *file, 
	const Image<int> & im, 
	int quality=75
    );
    int jpeg_image::save(
	const char * file, 
	const Image<int> & im, 
	int quality=75
    );

Сохранить окно картинки или всю картинку в файл. Файл всегда
сохраняется в виде RGB с качеством quality (0..100)

TODO
    - обработка ошибок

==================================================================
#include "image_google.h"

Работа с космоснимками, скачанными с maps.google.com.

Такие картинки имеют равноугольмую продольно-цилиндрическую проекцию
(mercator), и существуют в разных масштабах (1..18). В масштабе 1 весь
Земной шар изображается на одной плитке 256х256 точек. В масштабе
N вся картинка состоит из 2**(N-1)x2**(N-1) плиток 256х256.

Таким образом, при переходе к более крупному масштабу, каждая плитка
делится на 4 части. Части обозначаются буквами q, r, t, s. Исходная
плитка обозначается буквой t.  Адрес некоторой плитки записывается
строчкой из букв, например "tqqrtrssr".

    std::string google::tile2addr(int google_scale, int xt, int yt);

Определить адрес плитки по ее координатам.
Координаты считаются от левого-нижнего угла картинки и должны быть 
в диапазоне 0..2**(google_scale-1)-1.

Скачать такой кусочек можно командой:
wget http://kh<случайное число 0..2>.google.com/kh?n=404&v=9&t=<адрес плитки>

Считается, что локально такие файлы разложены по масштабам в
разные директории:
01/t.jpg
02/tq.jpg
02/tr.jpg
02/ts.jpg
02/tt.jpg
и т.д.

std::string google::tile2file(int google_scale, int xt, int yt);
Определить имя файла по координатам плитки.

    Point<int> google::lonlat2xy(int google_scale, Point<double> lonlat);
    Rect<int> lonlat2xy(int google_scale, Rect<double> lonlat){

Пересчет геодезических координат точки или прямоугольника в координаты
картинки google. Диапазон координат: 0..2**(google_scale-1)*256-1

    int load_to_image(
	const std::string & dir,
	int google_scale,
	Rect<int> src_rect,
	Image<int> & image,
	Rect<int> dst_rect
    );
    int load_to_image(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect,
        Image<int> & image, 
	const Rect<int> & dst_rect
    );

Загрузить прямоугольную область в прямоугольную область картинки.
Лишние данные по возможности не читаются и не сохраняются, время и
память экономятся. Используется возможность библиотеки libjpeg быстро
читать файлы, уменьшенные в 2,4,8 раз. Никакой интерполяции нет.

Область задается в координатах картинки google или в геодезических
координатах wgs84.

    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<int> & src_rect, 
	int scale=1
    );
    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect, 
	int scale=1
    );

Создать новую картинку и загрузить в нее некоторую область, уменьшенную в
scale раз.

Область задается в координатах картинки google или в геодезических
координатах wgs84.

struct google::points
Класс для организации произвольного доступа к данным с кэшированием

    google::points(
	std::string dir, 
	int google_scale, 
	int cache_size=200
    );

    int google::points::get(Point<int> p);
    int get(Point<double> p);

Получить цвет точки с заданными координатами картинки google или wgs84.

TODO
 - автоматическое скачивание

==================================================================


TODO
 - чтение hgt
 - srtm.h
 - геодезические преобразования
 - преобразования картинок
 - класс многоугольников
 - автоматическое определение формата картинки при чтении
 - Layer, умеющий загружать картинки в нужной проекции.
 

=============
Viewer-Workplane-Layer

- viewer - gtk-widget, который знает и показывает только workplane