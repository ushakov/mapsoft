В этой директории находятся разные небольшие библиотеки 
нижнего уровня: работа с точками, с цветом, с картинками, с геоданными и т.п.

=====================================================================
    Точка (point.h)

Point<T> - Точка на двумерной плоскости. Координаты типа T. Определено
сложение/вычитание, умножение/деление на число, сравнение...

=====================================================================
    Прямоугольник (rect.h)

Rect<T> прямоугольник на двумерной плоскости. Координаты типа T.

    T x,y,w,h;
    bool empty() const
    T width() const;
    T height() const;


    Rect<T> intersect (Rect<T> const & R1, Rect<T> const & R2);
    Rect<T> bounding_box (Rect<T> const & R1, Rect<T> const & R2);
    void clip_point_to_rect (Point<T> & p, const Rect<T> & r);
    bool point_in_rect (Point<T> & p, const Rect<T> & r);

=====================================================================

    Растровое изображение (image.h)

Image<T> -- двумерный массив элементов типа T

При присвоении и инициализации из другой картинки массив данных не
копируется! (устроен счетчик ссылок на массив, когда ссылок не
остается - массив удаляется)

Копирование картинки и данных: image1 = image.copy()

Доступ к точкам картинки: image.get(x,y),  image.set(x,y,c)

также есть версии set_na, set_a
(не устанавливать байт прозрачности, или аккуратно применить прозрачность (не работает?))

В функциях доступа не проверяется выход за границы картинки!
Компилить с ключом -O1 (скорость возрастет раза в три)

Размер картинки: image.w,  image.h

Получить размеры картинки:
  Rect<int> image.range() const;

=====================================================================

Преобразование Image<int> в Gdk::Pixbuf         (image_gdk.h)

Glib::RefPtr<Gdk::Pixbuf> make_pixbuf_from_image (const Image<int> & image);

Данные при этом преобразовании не копируются.

==================================================================
#include "cache.h"

    class Cache<K,V>

Кэш объектов типа V, упорядоченных по ключу типа K

    Cache (int capacity);
    Cache (Cache const & other);
    void swap (Cache<K,V> & other);
    Cache<K,V> & operator= (Cache<K,V> const& other);

    int add (K const & key, V const & value);
    V & get (K const & key);

    bool contains (K const & key);
    int space_remains();
    void clear();

==================================================================
#include "color.h"

    struct RGB
    struct RGBA

3- и 4-байтовый цвет. Преобразования друг в друга и в int.

    unsigned char r,g,b
    RGB();
    RGB(unsigned char r, unsigned char g, unsigned char b);
    RGB(int c);    
    operator int () const;
    operator RGBA () const;

И для RGBA - аналогично

Не слишком очевидно, надо ли часто использовать эти классы. 
Например, работать с Image<RGB> существенно медленнее, чем
с Image<int>.

С другой стороны, может быть приятно использовать для 
разный преобразований:
Image<int> image(100,100,RGB(r,g,b));
int c = RGB(b[3*i], b[3*i+1], b[3*i+2]);
и т.п.

TODO 
    * сложение и умножение на число??

==================================================================
#include "rainbow.h"

Радуга и пр. цветовые градиенты (из srtm02/color.h)


    RGB rainbow(int n, unsigned short mingrade);

mingrade - чему соответствует n=0:
0 - blue, 1 - сyan, 2 - green etc.
...

    RGB rainbow(int n, int min, int max, int grades, int mingrade);

...

==================================================================

#include "image_google_misc.h"

Все, что не уложилось в концепцию image loader'a: 
преобразования в геодезические координаты, произвольный доступ...
По идее все это выкинуть отсюда надо...


Пересчет геодезических координат точки или прямоугольника в координаты
картинки google. Диапазон координат: 0..2**(google_scale-1)*256-1

    Point<int> google::lonlat2xy(int google_scale, Point<double> lonlat);
    Rect<int> lonlat2xy(int google_scale, Rect<double> lonlat){

Загрузить прямоугольную область в прямоугольную область картинки.
Область задается в координатах wgs84.

    int load_to_image(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect,
        Image<int> & image, 
	const Rect<int> & dst_rect
    );

    Image<int> load(
	const std::string & dir, 
	int google_scale, 
	const Rect<double> & src_rect, 
	int scale=1
    );


struct google::points
Класс для организации произвольного доступа к данным с кэшированием

    google::points(
	std::string dir, 
	int google_scale, 
	int cache_size=200
    );

    int google::points::get(Point<int> p);
    int get(Point<double> p);

Получить цвет точки с заданными координатами картинки google или wgs84.

TODO
 - автоматическое скачивание

==================================================================


TODO
 - чтение/запись png
 - чтение hgt
 - srtm.h
 - геодезические преобразования
 - преобразования картинок
 - класс многоугольников
 - автоматическое определение формата картинки при чтении
 - Layer, умеющий загружать картинки в нужной проекции.
 

