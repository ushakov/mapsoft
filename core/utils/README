В этой директории находятся разные небольшие библиотеки 
нижнего уровня: работа с точками, с цветом, с картинками, с геоданными и т.п.

=====================================================================
    Точка (point.h)

Point<T> - Точка на двумерной плоскости. Координаты типа T. Определено
сложение/вычитание, умножение/деление на число, сравнение...

=====================================================================
    Прямоугольник (rect.h)

Rect<T> прямоугольник на двумерной плоскости. Координаты типа T.

    T x,y,w,h;
    bool empty() const
    T width() const;
    T height() const;


    Rect<T> intersect (Rect<T> const & R1, Rect<T> const & R2);
    Rect<T> bounding_box (Rect<T> const & R1, Rect<T> const & R2);
    void clip_point_to_rect (Point<T> & p, const Rect<T> & r);
    bool point_in_rect (Point<T> & p, const Rect<T> & r);

=====================================================================

    Растровое изображение (image.h)

Image<T> -- двумерный массив элементов типа T

При присвоении и инициализации из другой картинки массив данных не
копируется! (устроен счетчик ссылок на массив, когда ссылок не
остается - массив удаляется)

Копирование картинки и данных: image1 = image.copy()

Доступ к точкам картинки: image.get(x,y),  image.set(x,y,c)

также есть версии set_na, set_a
(не устанавливать байт прозрачности, или аккуратно применить прозрачность (не работает?))

В функциях доступа не проверяется выход за границы картинки!
Компилить с ключом -O1 (скорость возрастет раза в три)

Размер картинки: image.w,  image.h

Получить размеры картинки:
  Rect<int> image.range() const;

=====================================================================

Преобразование Image<int> в Gdk::Pixbuf         (image_gdk.h)

Glib::RefPtr<Gdk::Pixbuf> make_pixbuf_from_image (const Image<int> & image);

Данные при этом преобразовании не копируются.

==================================================================
#include "cache.h"

    class Cache<K,V>

Кэш объектов типа V, упорядоченных по ключу типа K

    Cache (int capacity);
    Cache (Cache const & other);
    void swap (Cache<K,V> & other);
    Cache<K,V> & operator= (Cache<K,V> const& other);

    int add (K const & key, V const & value);
    V & get (K const & key);

    bool contains (K const & key);
    int space_remains();
    void clear();

==================================================================
#include "color.h"

    struct RGB
    struct RGBA

3- и 4-байтовый цвет. Преобразования друг в друга и в int.

    unsigned char r,g,b
    RGB();
    RGB(unsigned char r, unsigned char g, unsigned char b);
    RGB(int c);    
    operator int () const;
    operator RGBA () const;

И для RGBA - аналогично

Не слишком очевидно, надо ли часто использовать эти классы. 
Например, работать с Image<RGB> существенно медленнее, чем
с Image<int>.

С другой стороны, может быть приятно использовать для 
разный преобразований:
Image<int> image(100,100,RGB(r,g,b));
int c = RGB(b[3*i], b[3*i+1], b[3*i+2]);
и т.п.

TODO 
    * сложение и умножение на число??

==================================================================
#include "rainbow.h"

Радуга и пр. цветовые градиенты (из srtm02/color.h)


    RGB rainbow(int n, unsigned short mingrade);

mingrade - чему соответствует n=0:
0 - blue, 1 - сyan, 2 - green etc.
...

    RGB rainbow(int n, int min, int max, int grades, int mingrade);

...

==================================================================
