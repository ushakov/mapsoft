slazav 09.07.2007

 * доделал geofig.cpp / geofig.h
 * сделал программу mapsoft_add2fig (раньше я пользовался такой программой
   из старого mapsoft'a)
 * при этом в io.cpp исчезла запись в fig - она использовала странный
   o_fig.cpp, надо бы здесь придумать что-то более разумное...

 * rect.h   Rect<T> rect_pump (Rect<T> const & R, Point<T> p);
 * point.h  operator Point<double>() const;
	    operator Point<int>() const;

 * упростил интерфейс Layer, вообще много всего 
   упростил в workplane и layers. Сейчас все хорошо работает.

 * убыстрения: при масштабах > 1 преобразуется не каждая точка,
   а каждая вторая, третья и т.п.
   При увеличении масштаба >1 и при уменьшении масштаба картинки 
   заново не загружаются.

 * am_edit_tpt.h

 * Сделал типы данных Color и Time, такие, что можно делать им
   boost::lexical_cast. Теперь при редактировании точек цвета и
   даты показываются по-человечески. Старые методы 
   (Options::get_time, mapsoft_time.h и т.д.) - убрал.
   Убрал почти все Options::get_*

 * Во все actions добавил проверку, чтоб они действовали только
   на активные layer'ы

 * am_edit_track.h
   для этого добавил преобразование g_track в/из Options, 
   а также странную функцию find_track, которая пока работает 
   неправильно :)

 * am_move_tpt.h
   am_delete_tpt.h

--------------------------------------------------------------------

slazav 06.07.2007

 * Сделал гораздо более правильные пересчеты линий 
   map2pt::line_frw и т.п. Без преобразований туда-обратно и оттого,
   кажется, без возможности зависания...
 * Исправил пару глупых ошибок в geo_convs

 * Произвел масштабную революцию.
   Теперь все масштабы отрабатываются на уровне g_map.
   Все работает (резина и выбор точек теперь работает правильно), 
   но на больших масштабах - медленно (понятно, что надо исправлять :))
   Теперь надо выкинуть очень много старого кода и сильно упростить все.

--------------------------------------------------------------------

slazav 01.07.2007

 * layer_geodata.h -- радиус поиска точек теперь передаю
   в качестве параметра функциям find_* со значением по умолчанию 3
 * geo_data.h -- ввел операторы умножения/деления g_map на число
   и прибавление/вычитания числа
   Указанные операции происходят со всеми растровыми координатами.

 * geo_io/io_xml -- исправил глупую ошибку из-за которой не читались
   треки

 * geo_data.h -- объект g_map по умолчанию инициализируется некоторым
   разумным образом.
   -- правда, при этом надо быть осторожным - если задать карту на весь
   мир, произойдет очень долгий затык в line_frw.

Два варианта взаимодействия workplane, layer и привязки:
1. привязку хранит workplane, у layer'a есть ссылка на привязку,
   workplane пинает layer'ы, при изменении привязки.
2. привязку хранит workplane, layer инициализируется в соответствии
   с какой-то привязкой, workplane строит новые layer'ы при изменении
   привязки (то есть, при всех перемасштабированиях :)).
Второй вариант довольно близок к тому, что есть сейчас, и мне он
нравится больше.

Суровый вопрос - кто должнен работать с геоданными и как они должны
быть упорядочены? Судя по всему работать должен workplane. Но
несколько объектов geo_data, как сейчас - это как-то очень запутанно
получается (кусочки треков собираются в один трек, треки собираются в
geo_data, несколько geo_data собираются в workplane). Можно было бы
для каждой  карты/трека/группы точек заводить свой layer, но карты все
же хочется группировать...

--------------------------------------------------------------------
slazav, 29.06.2007

 * Viewer::clear_cache переименовал в refresh() и немного изменил:
   теперь кэш плиток не очищается, но создаются запросы на обновление 
   всех плиток. Плитки перерисовываются поверх старых, без черного 
   экрана - очень красиво :).
 * В workplain добавил refresh_signal
 * Во вьюере workplain->refresh_signal цепляется к функции refresh()
   Так что workplain сама пинает viewer, когда что-то обновляется!
   Снаружи об обновлении вьюера заботиться обычно не надо.

  * разбирался с rubber. 
    инициализация происходит во Viewer::on_realize
  - не победил грязь, позникающую при скроллировании карты :(
    Все очень стреанно: проверил, что линии стираются всегда,
    с теми же координатами, что и рисовались, и между рисовкой
    и стиранием нет скроллирования.
    Еще, если бы скроллирование происходило как-то с задержкой -
    грязь получалась бы в виде параллельных линий, а она сходится
    к закрепленным на плоскости точкам...
    
  * перенес все, относящееся к рисованию rubber внутрь viewer'a.
    Теперь инициальзировать rubber не обязательно после того,
    как viewer обретет окно и мы можем вставить rubber в mapstate!

    Таким образом rubber и workplane стали равноправны:
    viewer при инициализации получает ссылки на W и R,
    цепляет куда нужно их сигналы signal_refresh и отрисовывает их
    как надо.
    ActionModes меняют только rubber и workplane, а про viewer ничего 
    не знают!

  * В MoveWaypoint добавил резину.

  - надо разбираться с масштабами. Сейчас растровые координаты в
    workplane и в layer'ах разные и из-за этого происходит много 
    нестыковок. Можно бы, конечно, устроить пересчет внутри workplain,
    но я бы подумал для начала, как сделать одни растровые координаты.

  * исправил глупую ошибку, что generic_dialog выдавал результат 0 
    от обеих кнопок.
   
--------------------------------------------------------------------
slazav, 27.06.2007
 * причесывание viewer'a
 * из viewer'а выкинута работа с масштабами - это дело workplane
   (при этом часть кода для изменения масштаба ушла в mapview.h -
   workplane ведь не знает, как надо менять window_origin viewer'a...)
 * mapview.h - добавил сохранение в файл всех доступных данных.
 * mapview.h - по кнопке 'r' обнуляет кэш вьюера. Пока actions сами не 
   умеют пинать вьюер, буду обходиться так...

--------------------------------------------------------------------
slazav, 22.06.2007
 * добавил am_add_wpt.h (очень уж хотелось получать координаты из карты! :))
 * в LayerGeoData добавил метод refresh() - пересчет границ данных
   (после добавления или редактирования такое надо делать) 
 * добавил am_move_wpt.h, пока без резины.
 * в layer.h вставил метод refresh(), который вызывается из 
   workplain::mark_level_dirty 
   Надо бы еще как-то layer пинать, что наши данные изменились...
 - не работает - сохранение наших отредактированных геоданных
 - не работает - обновление layer cache после исправления геоданных

--------------------------------------------------------------------
ushakov, 21.06.2007

 * сделаны режимы и действия! 
   viewer/generic_dialog.{h,cpp}
   viewer/action_manager.h
   viewer/action_mode.h
   viewer/am_edit_wpt.h

 * geo_io/geo_data.h: преобразования точек из/в Options

--------------------------------------------------------------------
ushakov, 17.06.2007

 * layers/layer_geodata.h: вычистил действия, пытаюсь вынести их в
   отдельный класс;
   создал методы получения точек и треков по координатам на плоскости
 
 * viewer/viewer.h: перенёс всю работу с событиями в programs/mapview.h,
   так как там будет весь контроль, а viewer будет только показывать и 
   отвечать на команды

 * geo_io/geo_convs.cpp: откатил часть Славиных изменений, так как иначе
   карты рисовались с полями и эти поля друг друга перекрывали (в основном
   откат касается обработки границ)

--------------------------------------------------------------------
slazav, 16.06.2007

 * programs/mapsoft_mapcnv -- делает не только растровую карту в
   нужном диапазоне координат, но и правильно привязанный fig-файл с
   этой картой.

 * loaders/image_ks.h -- загрузчик снимков с new.kosmosnimki.ru,
   аналогичный loaders/image_google.h

 * geo_io/geo_names.h, geo_io/geo_convs.h -- добавлена проекция 
   "google" (Кажется, это не совсем честный меркатор)

 * geo_io/geo_refs.h -- построение привязок для космоснимков

 * geo_io/geo_convs.h 
   Rect<int> map2map::bb_frw(const Rect<int> & R);
   Rect<int> map2map::bb_bck(const Rect<int> & R);
   -- преобразование прямоугольника (в произвольную фигуру) и 
   нахождение минимального прямоугольника, в котором она лежит.
   ("Какую часть картинки надо загрузить для преобразования")

 * Во вьюере cache_updater зачем-то делал сначала временную плитку 
   и сигналил (временную плитку также делает и draw_tile).
   Убрано.

 * geo_io/geo_convs.cpp -- Исправил ошибки из-за неправильного округления,
   и вообще все упростил в map2map::image_bck / image_frw

 * Удалил старый layer_google1.h и layer_geodata_g.h

 * Программы mapsoft_googleview и mapsoft_ksview
--------------------------------------------------------------------
