    Универсальный графический редактор

===========================================================================

Мы хотим работать со множеством разнородных графических объектов, каждый
из которых может быть как-то нарисован на растровой плоскости. Объекты
распределены по глубинам, способ рисования объекта определяется его
классом. Масштаб и геодезическая привязка плоскости является некоторой
дополнительной информацией, которую некоторые объекты могут
использовать.

Плоскость может быть разбита на плитки, чтоб удобно было кэшировать
данные. Каждая плитка знает, какие объекты на ней нарисованы (чтоб
быстро уметь перерисовываться, не перебирая все объекты).

Объекты должны кэшировать информацию, необходимую для отрисовки на плитках.
Вид кэша - на усмотрение класса объекта.

При изменении одного объекта мы получаем диапазон плиток, которые нам
надо перерисовать. При перерисовке данные для других объектов будут
извлечены из их кэша.

===========================================================================
    1. Графическая плоскость (GPlane)

Интерфейс описан в файле gplane.h:

class GPlane{
  public:
  virtual iImage draw(const iRect &range) const = 0;
};

Плоскость может отдать картинку на любой диапазон. Координаты плоскости
имеют тип int. Считается, что координаты лежат в диапазоне
INT_MIN/2 <= GCoordMin < x < GCoordMax <= INT_MAX/2 (так, что разность двух
координат всегда укладывается в тип int).

В том же файле gplane.h описаны несколько простых растровых плоскостей
для тестовых целей:

* GPlaneSolidFill -- отдает картинку, равномерно закрашенную
  определенным цветом. Используется по умолчанию в многопотоковых вьюерах
  в качестве "быстрой" плоскости.

* GPlaneTestTile  -- отдает область, закрашенную сине-зеленым
  градиентом. Удобна для тестирования вьюеров, позволяет видеть, какими
  именно кусками рисуется плоскость.

* GPlaneTestTileSlow -- то же, но с задержкой, пропорциональной размеру
  запрошенной области.

* GPlaneTestGrid --  рисует сетку с шагом степени 2.

* GPlaneTestGridSlow -- то же, но с задержкой.

TODO: класс "плоскость с объектами", "плоскость со слоями"

===========================================================================
    2. Вьюеры графической плоскости (SimpleViewer, MThreadViewer, DThreadViewer)

В файле simple_viewer.h описан простейший GTK-вьюер графической плоскости.
Он позволяет таскать плоскость по экрану, удерживая левую кнопку мыши.
По expose_event необходимые части плоскости перерисовываются.
Этот вьюер подходит только для быстро рисующихся плоскостей.

SimpleViewer V(plane);       // простой вьюер
iPoint pt = V.get_origin();  // получить положение окна
V.set_origin(pt);            // установить новое положение окна
GPlane * pl = V.get_plane(); // получить ссылку на растровую плоскость
V.set_plane(pl);             // заменить ссылку на растровую плоскость

TODO: функция reset(). И применить ее в set_plane.

В файле mthread_viewer.h на основе простого вьюера описан многопотоковый
вьюер, удобный для медленных плоскостей. По expose_event сразу рисуется
"быстрая" плоскость (по умолчанию - равномерно-черная), кроме того
запускается отдельный поток, готовящий картинку из "медленной"
плоскости. По мере готовности, картинка дорисовывается.

MThreadViewer V(plane);
V.set_fast_plane();             // установить "быструю" плоскость по умолчанию 
V.set_fast_plane(pl);           // установить "быструю" плоскость 
GPlane * pl = get_fast_plane(); // получить ссылку на быструю плоскость

Недостатки MThreadViewer:

* непонятно, как быстро остановить все потоки при необходимости обновить
  данные (как сделать reset()).
* плитки большого размера могут рисоваться долго. Более красиво было бы
  рисовать все небольшими плитками одинакового размера.

В файле dthread_viewer.h на основе простого вьюера описан двухпотоковый
вьюер с квадратными плитками.

DThreadViewer V(plane);
V.set_fast_plane();             // установить "быструю" плоскость по умолчанию 
V.set_fast_plane(pl);           // установить "быструю" плоскость 
GPlane * pl = get_fast_plane(); // получить ссылку на быструю плоскость

TODO: функции reset()!

===========================================================================
    4. Вьюер с резиной (RubberViewer<ViewerT>)

В файле rubber_viewer.h описан класс, добавляющий к любому вьюеру резину.

Резиновая линия - это пара точек и флаги привязки

флаги привязки:
бит 1 - координата X точки 1 привязана к мыши
бит 2 - координата Y точки 1 привязана к мыши
бит 3 - координата X точки 1 привязана к мыши
бит 4 - координата Y точки 1 привязана к мыши

Маски:
RUBBFL_PLANE     -- обе точки привязаны к плоскости
RUBBFL_MOUSE     -- обе точки привязаны к мыши
RUBBFL_MOUSE_P1  -- точка 1 привязана к мыши
RUBBFL_MOUSE_P2  -- точка 2 привязана к мыши
RUBBFL_MOUSE_P1X -- координата X точки 1 привязана к мыши
RUBBFL_MOUSE_P1Y -- координата Y точки 1 привязана к мыши
RUBBFL_MOUSE_P2X -- координата X точки 2 привязана к мыши
RUBBFL_MOUSE_P2Y -- координата Y точки 2 привязана к мыши

Класс RubberViewer определяет функции рисования и убирания резины.
Резина убирается перед движением мыши и перед рисованием данных и рисуется после.
Для этого переопределены функции draw_image (оборачивается функция из viewer) и
on_motion_notify_event.

RubberViewer<MyViewer> V(plane); // создать вьюер с резиной на основе MyViewer
V.rubber_add(pt1,pt2,flags);     // добавить сегмент резиновой линии
V.rubber_add(x1,y1,x2,y2,flags); // или так
V.rubber_clear();                // очистить всю резину

Здесь pt1 и pt2 -- координаты концов, а r1 и r2 -- флаги привязки

V.rubber_add_src_sq(p,size); // нарисовать квадратик 2size x 2size в точке плоскости p
V.rubber_add_dst_sq(size);   // нарисовать квадратик 2size x 2size привязанный к мыши
V.rubber_add_diag(p);        // линия от точки p до мыши
V.rubber_add_rect(p);        // прямоугольник от точки p до мыши

===========================================================================
    5. Вьюер с действиями (ActionViewer<ViewerT>)

В файле action.h описан интерфейс объекта-действия:

virtual std::string get_name(); // вернуть название действия (пока не используется)
virtual void init();            // начать действие
virtual void reset();           // прервать действие
virtual void click(const iPoint & p, const Gdk::ModifierType & state);
  // обработать нажатие кнопки мыши.

В файле action_viewer.h описан класс, добавляющий к любому вьюеру действия.

ActionViewer<MyViewer> V(plane); // создать вьюер с действиями на основе MyViewer
V.action_add(Action * a); //
V.action_clear();         // удалить все действия
V.action_select(int a);   // прервать текущее действие и выбрать новое

===========================================================================




    6. Графический объект (GObject) -- TODO

Объект, умеющий нарисоваться на растровой картинке.

Получает картинку, ее координаты на растровой плоскости,
и информацию о привязки и масштабе растровой плоскости.
Рисует что-то на картинке. Что-то в таком духе:
int GObject::draw(GImage & img, const GPoint & origin, const GPlaneInfo & info);

GPlaneInfo -- информация о привязке и масштабе. Объект может использовать или
не использовать ее по своему усмотрению.
(jpeg-картинка может эффективно грузиться с уменьшением,
иконка может вообще игнорировать масштаб/привязку...)

Объект может (и должен) кэшировать информацию, нужную для рисования
определенной области. Формат данных в кэше - на усмотрение объекта: это может
быть набор точек для рисования линии или преобразованная растровая картинка.

Объект может отдавать "сложность" кэширования и рисования. 
Это хочется применять для умного разбиения плоскости на плитки в зависимости от
сложности рисования объектов на плитках. Полезность этого пока
непонятна.

Объект может предоставлять функции поиска (ткнули в такую-то точку - вернули
объект или точку объекта, или сегмент объекта или т.п.).


