    Универсальный графический редактор

===========================================================================
    0. Обзор

Мы хотим работать со множеством разнородных графических объектов, каждый
из которых может быть как-то нарисован на растровой плоскости. Объекты
распределены по глубинам, способ рисования объекта определяется его
классом. Масштаб и геодезическая привязка плоскости является некоторой
дополнительной информацией, которую некоторые объекты могут
использовать.

Плоскость может быть разбита на плитки, чтоб удобно было кэшировать
данные. Каждая плитка знает, какие объекты на ней нарисованы (чтоб
быстро уметь перерисовываться, не перебирая все объекты).

Объекты должны кэшировать информацию, необходимую для отрисовки на плитках.
Вид кэша - на усмотрение класса объекта.

При изменении одного объекта мы получаем диапазон плиток, которые нам
надо перерисовать. При перерисовке данные для других объектов будут
извлечены из их кэша.

===========================================================================
    1. Графическая плоскость (GPlane)

Интерфейс описан в файле gplane.h:

class GPlane{
  public:
  virtual iImage draw(const iRect &range) const = 0;
};

Плоскость может отдать картинку на любой диапазон. Координаты плоскости
имеют тип int. Считается, что координаты лежат в диапазоне 
INT_MIN/2 <= GCoordMin < x < GCoordMax <= INT_MAX/2 (так, что разность двух
координат всегда укладывается в тип int).

TODO: протестировать SimpleViewer на небольших значениях  GCoordMin/GCoordMax!

В том же файле gplane.h описаны несколько простых растровых плоскостей
для тестовых целей:

* GPlaneSolidFill -- отдает картинку, равномерно закрашенную
  определенным цветом. Используется по умолчанию в многопотоковых вьюерах
  в качестве "быстрой" плоскости.

* GPlaneTestTile  -- отдает область, закрашенную сине-зеленым
  градиентом. Удобна для тестирования вьюеров, пзволяет видеть, какими
  именно кусками рисуется плоскость.

* GPlaneTestTileSlow -- то же, но с задержкой, пропорциональной размеру
  запрошенной области.

* GPlaneTestGrid --  рисует сетку с шагом степени 2.

* GPlaneTestGridSlow -- то же, но с задержкой.

TODO: класс "плоскость, содержащая объекты"

===========================================================================
    2. Вьюеры графической плоскости (SimpleViewer, MThreadViewer)

В файле simple_viewer.h описан простейший GTK-вьюер графической плоскости.
Он позволяет таскать плоскость по экрану, удерживая левую кнопку мыши.
По expose_event необходимые части плоскости перерисовываются.
Этот вьюер подходит только для быстро рисующихся плоскостей.

SimpleViewer V(plane);       // простой вьюер
iPoint pt = V.get_origin();  // получить положение окна
V.set_origin(pt);            // установить новое положение окна
GPlane * pl = V.get_plane(); // получить ссылку на растровую плоскость
V.set_plane(pl);             // заменить ссылку на растровую плоскость

TODO: функция reset(). И применить ее в set_plane.

В файле mthread_viewer.h на основе простого вьюера описан многопотоковый
вьюер, удобный для медленных плоскостей. По expose_event сразу рисуется
"быстрая" плоскость (по умолчанию - равномерно-черная), кроме того
запускается отдельный поток, готовящий картинку из "медленной"
плоскости. По мере готовности, картинка перерисовывается.

MThreadViewer V(plane);
V.set_fast_plane();             // установить "быструю" плоскость по умолчанию 
V.set_fast_plane(pl);           // установить "быструю" плоскость 
GPlane * pl = get_fast_plane(); // получить ссылку на быструю плоскость

Недостатки MThreadViewer:

* непонятно, как быстро остановить все потоки при необходимости обновить
  данные.
* плитки большого размера могут рисоваться долго. Более красиво было бы
  рисовать все небольшими плитками одинакового размера.

TODO: Для решения этих недостатков надо бы сделать вьюер с двумя потоками и квадратными
плитками, как уже был у нас в mapsoft/viewer

===========================================================================
    4. Вьюер с резиной (RubberViewer<ViewerType>)

В файле rubber_viewer.h описан класс, добавляющий к любому вьюеру резину.

Резиновая линия - это пара точек и пара флагов привязки (первый бит
флага привязки показывает, привязана ли к мыши координата x, второй -
привязана ли к мыши координата y).

При добавлении резины ко вьюеру определяются функции рисования и убирания резины.
Резина убирается перед движением мыши и перед рисованием данных и рисуется после.
Для этого переопределены функции draw_image (оборачивается функция из viewer) и 
on_motion_notify_event.

RubberViewer<MyViewer> V(plane); // создать вьюер с резиной на основе MyViewer
V.rubber_add(pt1,r1,pt2,r2);     // добавить сегмент резиновой линии
V.rubber_add(x1,y1,r1,x2,y2,r2); // или так
V.rubber_clear();                // очистить всю резину

===========================================================================

    5. Графический объект (GObject) -- TODO

Объект, умеющий нарисоваться на растровой картинке.

Получает картинку, ее координаты на растровой плоскости,
и информацию о привязки и масштабе растровой плоскости.
Рисует что-то на картинке. Что-то в таком духе:
int GObject::draw(GImage & img, const GPoint & origin, const GPlaneInfo & info);

GPlaneInfo -- информация о привязке и масштабе. Объект может использовать или
не использовать ее по своему усмотрению.
(jpeg-картинка может эффективно грузиться с уменьшением,
иконка может вообще игнорировать масштаб/привязку...)

Объект может (и должен) кэшировать информацию, нужную для рисования
определенной области. Формат данных в кэше - на усмотрение объекта: это может
быть набор точек для рисования линии или преобразованная растровая картинка.

Объект может отдавать "сложность" кэширования и рисования. 
Это хочется применять для умного разбиения плоскости на плитки в зависимости от
сложности рисования объектов на плитках. Полезность этого пока
непонятна.

Объект может предоставлять функции поиска (ткнули в такую-то точку - вернули
объект или точку объекта, или сегмент объекта или т.п.).


